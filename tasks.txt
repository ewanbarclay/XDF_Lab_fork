

In this project you analyse imaging from the Hubble Space Telescope. Specifically, the Hubble Ultra Deep Field, also known (due to a re-branding exercise) as the eXtreme Deep Field (XDF). The ultimately aim is to find an example of a high-redshift galaxy.

Hubble imaging of the XDF consists of imaging in 8 optical and near-IR filters stretching from the blue end of the optical (~400nm) to almost 2000nm in the near-IR.

For each filter there are a pair of images, a science (sci) and weight (wht) images. These respectively contain the signal and an estimate of the noise in each pixel. For the science image the units are electrons per second (e/s).


Due to the way in which these high-level science images were produced many of the pixels have zero signal. A mask file is provided to exclude these pixels.



# ----- basic

[example1.py]

# 1a: The distribution of pixel values will contain a contribution from a gaussian centred around ~0.0 corresponding to the noise combined with a positive distribution corresponding to the real signal.

- Model the noise as a gaussian and estimate \sigma. HINT: there should be no signal contribution to the negative pixels so you can use them to measure $\sigma$. $\sigma$ of just the negative half of a distribution is simply $-P_{31.7}$.

- Exclude pixels with magnitude $>10\sigma$ and plot both a density histogram (HINT: use plt.hist(..., density = True)) of the pixel distribution and a normal distribution with the same $\sigma$.

[example2.py]

# 1b: Produce plots of each un-masked weight map. You should do this efficiently with a loop. DO NOT simply repeat the code 8 times. You should notice that the weight maps for the ['f435w','f606w', 'f775w','f850lp'] are different from those for ['f105w','f125w','f140w','f160w']. This is because images in the former filters were obtained using the advanced camera for surveys (ACS) instrument while the latter were obtained with Wide Field Camera 3 (WFC3). ACS and WFC3 have different field-of-views. For the WFC3 filters also notice the "holes" in the weight maps corresponding to bad areas of the detector (camera).

[example2.py, example3.py, example4.py]

# 1c: Produce a false-colour image of the entire masked XDF using all 8 filters. You should define 3 groups of consecutive filters (e.g. ['f435w','f606w'], ['f775w','f850lp'], ['f105w','f125w','f140w','f160w']), combine each group, and then combine those stacks together into an RGB image. Congratulations you've now created your own pretty HUDF image. By choosing different filters in each group and playing with the scaling you can make an entirely unique and original incarnation.



# 2 --- Detecting sources

Now we're going to detect sources in a portion of the HUDF.

[example3.py]

# 2a: Create a detection science and weight image by stacking the F105W, F125W, F140W, and F160W images together. You will use this image to detect faint sources.

[example5.py]

# 2b: Create a significance map of the central 400 pixel wide area centred on (3100, 1800).

[example6.py]

# 2c: Create a segmentation image (with no de-blending) of the same region assuming npixels = 5 and threshold = 2.5. Systematically explore the impact of changing npixels (must be an integer) and threshold on the number of sources detected.

[example6.py]

# 2d: Sticking with npixels = 5 and threshold = 2.5 now explore the impact of the parameters that control de-blending on the number of sources.

[example7.py]

# 2e: measure the signal (e/s) of all the sources in the region. To do this you can combine the segmentation map with the detection science image. Plot a histogram. Do the same for the de-blended image and discuss the difference.

[example7.py, example8.py]

# 2f: using the original (simple, un-blended) segmentation map measure the signal and noise (or error) of every object in every single band and create a dictionary catalogue. Save this catalogue for use later.


# 3 --- Finding high-redshift galaxies

High-redshift galaxies can be identified using the Lyman-break technique. This takes advantage of a strong break in the spectrum of galaxies caused by the absorption of ionising photons by inter-stellar and inter-galactic hydrogen.

[example9.py]

# 3a: Read in you catalogue and convert the signal into a flux (nJy) using the conversion dictionary in example9.py. Plot f_{f105w}/f_{125w} vs. f_{f850lp}/f_{105w} for all your objects.


# 3b: Building on 3a we can now apply a (relatively) simple set of selection criteria to identify distant galaxies.

expand the selection criteria discussion.


[example7.py]

# 3c: Make cut out images of your candidate(s), if you have any. This could be based simply on the detection image, your RGB image, or the individual filter images. HINT:
